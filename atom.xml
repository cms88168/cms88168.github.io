<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.cmsj.in</id>
    <title>蒼茫世界</title>
    <updated>2021-09-10T14:15:26.339Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.cmsj.in"/>
    <link rel="self" href="https://www.cmsj.in/atom.xml"/>
    <subtitle>蒼茫世界,誰主沉浮</subtitle>
    <logo>https://www.cmsj.in/images/avatar.png</logo>
    <icon>https://www.cmsj.in/favicon.ico</icon>
    <rights>All rights reserved 2021, 蒼茫世界</rights>
    <entry>
        <title type="html"><![CDATA[Java程序设计：使用NotePad++编译并运行单文件]]></title>
        <id>https://www.cmsj.in/post/java-cheng-xu-she-ji-shi-yong-notepadbian-yi-bing-yun-xing-dan-wen-jian/</id>
        <link href="https://www.cmsj.in/post/java-cheng-xu-she-ji-shi-yong-notepadbian-yi-bing-yun-xing-dan-wen-jian/">
        </link>
        <updated>2020-08-25T13:50:35.000Z</updated>
        <summary type="html"><![CDATA[<p>练习时经常打开一些单个的.java文件，使用IDEA的话未免太过笨重，研究了一下，在原来就在使用的文本编辑器NotePad++中设置一番便可方便地编译运行了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>练习时经常打开一些单个的.java文件，使用IDEA的话未免太过笨重，研究了一下，在原来就在使用的文本编辑器NotePad++中设置一番便可方便地编译运行了。</p>
<!-- more -->
<p>点击菜单栏-运行-运行按钮，如图所示：<img src="https://www.cmsj.in/post-images/1631282232824.png" alt="" loading="lazy"></p>
<p>在运行框中分别输入如下的指令，点击保存，输入对应的名称，就可以在运行菜单看到它们了。</p>
<p>Java编译-UTF-8<br>
<code>cmd /k javac -encoding UTF-8 &quot;$(FULL_CURRENT_PATH)&quot; &amp;&amp; echo 编译成功！ &amp; PAUSE &amp; EXIT</code></p>
<p>Java编译-GBK<br>
<code>cmd /k javac &quot;$(FULL_CURRENT_PATH)&quot; &amp;&amp; echo 编译成功！ &amp; PAUSE &amp; EXIT</code></p>
<p>Java运行-UTF-8<br>
<code>cmd /k cd /d &quot;$(CURRENT_DIRECTORY)&quot; &amp; java -Dfile.encoding=UTF-8 &quot;$(NAME_PART)&quot; &amp; pause &amp; exit</code></p>
<p>Java运行-GBK<br>
<code>cmd /k cd /d &quot;$(CURRENT_DIRECTORY)&quot; &amp; java &quot;$(NAME_PART)&quot; &amp; pause &amp; exit</code></p>
<p>当然系统中需要安装JDK并配置好环境变量哦:)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java程序设计：统计代码的执行时间的3种方法]]></title>
        <id>https://www.cmsj.in/post/java-cheng-xu-she-ji-tong-ji-dai-ma-de-zhi-xing-shi-jian-de-3-chong-fang-fa/</id>
        <link href="https://www.cmsj.in/post/java-cheng-xu-she-ji-tong-ji-dai-ma-de-zhi-xing-shi-jian-de-3-chong-fang-fa/">
        </link>
        <updated>2020-08-20T04:44:24.000Z</updated>
        <summary type="html"><![CDATA[<p>在日常开发中经常需要测试一些代码的执行时间，所以本文就汇总了一些 Java 中比较常用的执行时间统计方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在日常开发中经常需要测试一些代码的执行时间，所以本文就汇总了一些 Java 中比较常用的执行时间统计方法。</p>
<!-- more -->
<h1 id="方法一systemcurrenttimemillis">方法一：System.currentTimeMillis</h1>
<p>此方法为 Java 内置的方法，使用 System#currentTimeMillis 来统计执行的时间（统计单位：毫秒），示例代码如下：</p>
<pre><code class="language-java">public class TimeIntervalTest {
    public static void main(String[] args) throws InterruptedException {
        // 开始时间
        long stime = System.currentTimeMillis();
        // 执行时间（1s）
        Thread.sleep(1000);
        // 结束时间
        long etime = System.currentTimeMillis();
        // 计算执行时间
        System.out.printf(&quot;执行时长：%d 毫秒.&quot;, (etime - stime));
    }
}
</code></pre>
<p>以上程序的执行结果为：</p>
<p><code>执行时长：1000 毫秒.</code></p>
<h1 id="方法二systemnanotime">方法二：System.nanoTime</h1>
<p>此方法为 Java 内置的方法，使用 System#nanoTime 来统计执行时间（统计单位：纳秒），它的执行方法和 System#currentTimeMillis 类似，示例代码如下：</p>
<pre><code class="language-java">public class TimeIntervalTest {
    public static void main(String[] args) throws InterruptedException {
        // 开始时间
        long stime = System.nanoTime();
        // 执行时间（1s）
        Thread.sleep(1000);
        // 结束时间
        long etime = System.nanoTime();
        // 计算执行时间
        System.out.printf(&quot;执行时长：%d 纳秒.&quot;, (etime - stime));
    }
}
</code></pre>
<p>以上程序的执行结果为：</p>
<p><code>执行时长：1000769200 纳秒.</code></p>
<p><code>小贴士：1 毫秒 = 100 万纳秒。</code></p>
<h1 id="方法三new-date">方法三：new Date</h1>
<p>此方法也是 Java 的内置方法，在开始执行前 new Date() 创建一个当前时间对象，在执行结束之后 new Date() 一个当前执行时间，然后再统计两个 Date 的时间间隔，示例代码如下：</p>
<pre><code class="language-java">import java.util.Date;
 
public class TimeIntervalTest {
    public static void main(String[] args) throws InterruptedException {
        // 开始时间
        Date sdate = new Date();
        // 执行时间（1s）
        Thread.sleep(1000);
        // 结束时间
        Date edate = new Date();
        //  统计执行时间（毫秒）
        System.out.printf(&quot;执行时长：%d 毫秒.&quot; , (edate.getTime() - sdate.getTime())); 
    }
}
</code></pre>
<p>以上程序的执行结果为：</p>
<p><code>执行时长：1000 毫秒.</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java程序设计：更改Swing的Look and Feel UI皮肤]]></title>
        <id>https://www.cmsj.in/post/java-cheng-xu-she-ji-geng-gai-swing-de-look-and-feel-ui-pi-fu/</id>
        <link href="https://www.cmsj.in/post/java-cheng-xu-she-ji-geng-gai-swing-de-look-and-feel-ui-pi-fu/">
        </link>
        <updated>2020-08-17T02:20:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Java自身UI界面太丑怎么办？通过在加载窗口时加入以下代码就可以将Java应用程序GUI设置成当前系统风格：</p>
<pre><code class="language-java">try {
    // 设置本机系统外观
	UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
} catch (Exception e) {
	e.printStackTrace();
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>Java自身UI界面太丑怎么办？通过在加载窗口时加入以下代码就可以将Java应用程序GUI设置成当前系统风格：</p>
<pre><code class="language-java">try {
    // 设置本机系统外观
	UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
} catch (Exception e) {
	e.printStackTrace();
}
</code></pre>
<!-- more -->
<p>根据UIManager源程序，</p>
<pre><code class="language-java">private static LookAndFeelInfo[] installedLAFs;

    static {
        ArrayList&lt;LookAndFeelInfo&gt; iLAFs = new ArrayList&lt;LookAndFeelInfo&gt;(4);
        iLAFs.add(new LookAndFeelInfo(
                      &quot;Metal&quot;, &quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;));
        iLAFs.add(new LookAndFeelInfo(
                      &quot;Nimbus&quot;, &quot;javax.swing.plaf.nimbus.NimbusLookAndFeel&quot;));
        iLAFs.add(new LookAndFeelInfo(&quot;CDE/Motif&quot;,
                  &quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;));

        // Only include windows on Windows boxs.
        OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());
        if (osType == OSInfo.OSType.WINDOWS) {
            iLAFs.add(new LookAndFeelInfo(&quot;Windows&quot;,
                        &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;));
            if (Toolkit.getDefaultToolkit().getDesktopProperty(
                    &quot;win.xpstyle.themeActive&quot;) != null) {
                iLAFs.add(new LookAndFeelInfo(&quot;Windows Classic&quot;,
                 &quot;com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel&quot;));
            }
        }
        else if (osType == OSInfo.OSType.MACOSX) {
            iLAFs.add(new LookAndFeelInfo(&quot;Mac OS X&quot;, &quot;com.apple.laf.AquaLookAndFeel&quot;));
        }
        else {
            // GTK is not shipped on Windows.
            iLAFs.add(new LookAndFeelInfo(&quot;GTK+&quot;,
                  &quot;com.sun.java.swing.plaf.gtk.GTKLookAndFeel&quot;));
        }
        installedLAFs = iLAFs.toArray(new LookAndFeelInfo[iLAFs.size()]);
    }
</code></pre>
<p>想要更改为windows样式只需要<br>
<code>UIManager.setLookAndFeel(&quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;);</code><br>
就可以了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java程序设计：用“埃氏筛法”求2～n以内的素数]]></title>
        <id>https://www.cmsj.in/post/java-cheng-xu-she-ji-yong-ai-shi-shai-fa-qiu-2~n-yi-nei-de-su-shu/</id>
        <link href="https://www.cmsj.in/post/java-cheng-xu-she-ji-yong-ai-shi-shai-fa-qiu-2~n-yi-nei-de-su-shu/">
        </link>
        <updated>2020-08-15T15:18:23.000Z</updated>
        <summary type="html"><![CDATA[<p>用“埃氏筛法”求2～100以内的素数。2～100以内的数，先去掉2的倍数，再去掉3的倍数，再去掉5的倍数，……依此类推，最后剩下的就是素数。</p>
<p>‏</p>
]]></summary>
        <content type="html"><![CDATA[<p>用“埃氏筛法”求2～100以内的素数。2～100以内的数，先去掉2的倍数，再去掉3的倍数，再去掉5的倍数，……依此类推，最后剩下的就是素数。</p>
<p>‏</p>
<!-- more -->
<p>‏要求使用数组及增强的for语句。</p>
<p>写了个带图形界面的，源代码如下：</p>
<h3 id="mainjava">Main.java</h3>
<pre><code class="language-java">package leet;


import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        Gui.init();
    }

    public static String calc(int num) {
        boolean[] isPrime = new boolean[num];
        Arrays.fill(isPrime, true);
        //1不考虑，设为false
        isPrime[0] = false;
        //2是质数，从3开始。
        int count = 1;
        for (int i = 2; i &lt; num; i++) {
            for (int j = 1; j &lt; i; j++) {
                if (isPrime[j]) {
                    if ((i + 1) % (j + 1) == 0) {
                        isPrime[i] = false;
                        break;
                    }
                }
            }
            if (isPrime[i]) {
                count++;
            }
        }
        int[] res = new int[count];

        for (int i = 0, j = 0; j &lt; count; i++) {
            if (isPrime[i]) {
                res[j] = i + 1;
                j++;
            }
        }
        String result = &quot;素数共有&quot; + count + &quot;个，分别为：\n&quot;;
        for (int i : res) {
            result = result + i + &quot;， &quot;;
        }
        return result;
    }
}

</code></pre>
<h3 id="guijava">Gui.java</h3>
<pre><code class="language-java">package leet;

import javax.swing.*;

public class Gui {
    private JPanel panel1;
    private JButton button1;
    private JTextArea textArea1;
    private JTextField textField1;
    private JLabel label1;
    private JScrollPane jscroll;

    public Gui() {
        button1.addActionListener(e -&gt; textArea1.setText(Main.calc(getIntTextField1())));
    }

    public static void init() {
        try {
            // 设置本机系统外观
            UIManager.setLookAndFeel(&quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }
        JFrame frame = new JFrame(&quot;Gui&quot;);
        frame.setContentPane(new Gui().panel1);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }

    public int getIntTextField1() {
        int ret = 0;
        try {
            ret = Integer.parseInt(textField1.getText());
            if (ret &lt; 3) {
                ret = 0;
                throw new NumberFormatException();
            }
        } catch (NumberFormatException e) {
            e.printStackTrace();
            textArea1.setText(&quot;请输入不小于2的整数！&quot;);
        }
        return ret;
    }
}

</code></pre>
<h3 id="运行效果如图">运行效果如图：</h3>
<figure data-type="image" tabindex="1"><img src="https://www.cmsj.in/post-images/1631116714046.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java程序设计：基本数据类型]]></title>
        <id>https://www.cmsj.in/post/java-cheng-xu-she-ji-ji-ben-shu-ju-lei-xing/</id>
        <link href="https://www.cmsj.in/post/java-cheng-xu-she-ji-ji-ben-shu-ju-lei-xing/">
        </link>
        <updated>2020-08-10T14:07:44.000Z</updated>
        <summary type="html"><![CDATA[<p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 的两大数据类型:</p>
<p>内置数据类型<br>
引用数据类型<br>
<img src="https://www.cmsj.in/post-images/1631025505934.png" alt="" loading="lazy"></p>
<h1 id="内置数据类型">内置数据类型</h1>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
]]></summary>
        <content type="html"><![CDATA[<p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 的两大数据类型:</p>
<p>内置数据类型<br>
引用数据类型<br>
<img src="https://www.cmsj.in/post-images/1631025505934.png" alt="" loading="lazy"></p>
<h1 id="内置数据类型">内置数据类型</h1>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<h2 id="-more-byte"><!-- more --><br>
<img src="https://www.cmsj.in/post-images/1631024418478.png" alt="" loading="lazy"><br>
byte：</h2>
<p>byte 数据类型是8位、有符号的，以二进制补码表示的整数；<br>
最小值是 -128（-2^7）；<br>
最大值是 127（2^7-1）；<br>
默认值是 0；<br>
byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；<br>
例子：byte a = 100，byte b = -50。</p>
<h2 id="short">short：</h2>
<p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>
最小值是 -32768（-2^15）；<br>
最大值是 32767（2^15 - 1）；<br>
Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>
默认值是 0；<br>
例子：short s = 1000，short r = -20000。</p>
<h2 id="int">int：</h2>
<p>int 数据类型是32位、有符号的以二进制补码表示的整数；<br>
最小值是 -2,147,483,648（-2^31）；<br>
最大值是 2,147,483,647（2^31 - 1）；<br>
一般地整型变量默认为 int 类型；<br>
默认值是 0 ；<br>
例子：int a = 100000, int b = -200000。</p>
<h2 id="long">long：</h2>
<p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；<br>
最小值是 -9,223,372,036,854,775,808（-2^63）；<br>
最大值是 9,223,372,036,854,775,807（2^63 -1）；<br>
这种类型主要使用在需要比较大整数的系统上；<br>
默认值是 0L；<br>
例子： long a = 100000L，Long b = -200000L。<br>
&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。</p>
<h2 id="float">float：</h2>
<p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>
float 在储存大型浮点数组的时候可节省内存空间；<br>
默认值是 0.0f；<br>
浮点数不能用来表示精确的值，如货币；<br>
例子：float f1 = 234.5f。</p>
<h2 id="double">double：</h2>
<p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；<br>
浮点数的默认类型为 double 类型；<br>
double类型同样不能表示精确的值，如货币；<br>
默认值是 0.0d；<br>
例子：</p>
<p>double   d1  = 7D ;<br>
double   d2  = 7.;<br>
double   d3  =  8.0;<br>
double   d4  =  8.D;<br>
double   d5  =  12.9867;<br>
7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p>
<h2 id="boolean">boolean：</h2>
<p>boolean数据类型表示一位的信息；<br>
只有两个取值：true 和 false；<br>
这种类型只作为一种标志来记录 true/false 情况；<br>
默认值是 false；<br>
例子：boolean one = true。</p>
<h2 id="char">char：</h2>
<p>char 类型是一个单一的 16 位 Unicode 字符；<br>
最小值是 \u0000（十进制等效值为 0）；<br>
最大值是 \uffff（即为 65535）；<br>
char 数据类型可以储存任何字符；<br>
例子：char letter = 'A';。</p>
<h2 id="实例">实例</h2>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p>
<p>实例</p>
<pre><code class="language-java">public class PrimitiveTypeTest {  
    public static void main(String[] args) {  
        // byte  
        System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);  
        System.out.println(&quot;包装类：java.lang.Byte&quot;);  
        System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE);  
        System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);  
        System.out.println();  
  
        // short  
        System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);  
        System.out.println(&quot;包装类：java.lang.Short&quot;);  
        System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE);  
        System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE);  
        System.out.println();  
  
        // int  
        System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);  
        System.out.println(&quot;包装类：java.lang.Integer&quot;);  
        System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE);  
        System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE);  
        System.out.println();  
  
        // long  
        System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);  
        System.out.println(&quot;包装类：java.lang.Long&quot;);  
        System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE);  
        System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE);  
        System.out.println();  
  
        // float  
        System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);  
        System.out.println(&quot;包装类：java.lang.Float&quot;);  
        System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE);  
        System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE);  
        System.out.println();  
  
        // double  
        System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);  
        System.out.println(&quot;包装类：java.lang.Double&quot;);  
        System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE);  
        System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE);  
        System.out.println();  
  
        // char  
        System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);  
        System.out.println(&quot;包装类：java.lang.Character&quot;);  
        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  
        System.out.println(&quot;最小值：Character.MIN_VALUE=&quot;  
                + (int) Character.MIN_VALUE);  
        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  
        System.out.println(&quot;最大值：Character.MAX_VALUE=&quot;  
                + (int) Character.MAX_VALUE);  
    }  
}
</code></pre>
<p>编译以上代码输出结果如下所示：</p>
<p>基本类型：byte 二进制位数：8<br>
包装类：java.lang.Byte<br>
最小值：Byte.MIN_VALUE=-128<br>
最大值：Byte.MAX_VALUE=127</p>
<p>基本类型：short 二进制位数：16<br>
包装类：java.lang.Short<br>
最小值：Short.MIN_VALUE=-32768<br>
最大值：Short.MAX_VALUE=32767</p>
<p>基本类型：int 二进制位数：32<br>
包装类：java.lang.Integer<br>
最小值：Integer.MIN_VALUE=-2147483648<br>
最大值：Integer.MAX_VALUE=2147483647</p>
<p>基本类型：long 二进制位数：64<br>
包装类：java.lang.Long<br>
最小值：Long.MIN_VALUE=-9223372036854775808<br>
最大值：Long.MAX_VALUE=9223372036854775807</p>
<p>基本类型：float 二进制位数：32<br>
包装类：java.lang.Float<br>
最小值：Float.MIN_VALUE=1.4E-45<br>
最大值：Float.MAX_VALUE=3.4028235E38</p>
<p>基本类型：double 二进制位数：64<br>
包装类：java.lang.Double<br>
最小值：Double.MIN_VALUE=4.9E-324<br>
最大值：Double.MAX_VALUE=1.7976931348623157E308</p>
<p>基本类型：char 二进制位数：16<br>
包装类：java.lang.Character<br>
最小值：Character.MIN_VALUE=0<br>
最大值：Character.MAX_VALUE=65535</p>
<p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的&quot;E+数字&quot;表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 103 =3140，3.14E-3 就是 3.14 x 10-3 =0.00314。</p>
<p>实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h2 id="类型默认值">类型默认值</h2>
<p>下表列出了 Java 各个类型的默认值：</p>
<ul>
<li>数据类型	默认值</li>
<li>byte	      0</li>
<li>short	      0</li>
<li>int	        0</li>
<li>long	      0L</li>
<li>float	       0.0f</li>
<li>double	0.0d</li>
<li>char	       'u0000'</li>
<li>String (or any object)	null</li>
<li>boolean	false</li>
</ul>
<h2 id="实例-2">实例</h2>
<pre><code class="language-java">public class Test {
    static boolean bool;
    static byte by;
    static char ch;
    static double d;
    static float f;
    static int i;
    static long l;
    static short sh;
    static String str;
 
    public static void main(String[] args) {
        System.out.println(&quot;Bool :&quot; + bool);
        System.out.println(&quot;Byte :&quot; + by);
        System.out.println(&quot;Character:&quot; + ch);
        System.out.println(&quot;Double :&quot; + d);
        System.out.println(&quot;Float :&quot; + f);
        System.out.println(&quot;Integer :&quot; + i);
        System.out.println(&quot;Long :&quot; + l);
        System.out.println(&quot;Short :&quot; + sh);
        System.out.println(&quot;String :&quot; + str);
    }
}
</code></pre>
<p>实例输出结果为：</p>
<p>Bool     :false<br>
Byte     :0<br>
Character:<br>
Double   :0.0<br>
Float    :0.0<br>
Integer  :0<br>
Long     :0<br>
Short    :0<br>
String   :null</p>
<h1 id="引用类型">引用类型</h1>
<p>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。<br>
对象、数组都是引用数据类型。<br>
所有引用类型的默认值都是null。<br>
一个引用变量可以用来引用任何与之兼容的类型。<br>
例子：Site site = new Site(&quot;Runoob&quot;)。</p>
<h2 id="java-常量">Java 常量</h2>
<p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>
<p>final double PI = 3.1415927;<br>
虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>
<p>字面量可以赋给任何内置类型的变量。例如：</p>
<p>byte a = 68;<br>
char a = 'A'<br>
byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p>
<p>当使用字面量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：</p>
<p>int decimal = 100;<br>
int octal = 0144;<br>
int hexa =  0x64;</p>
<p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p>
<p>&quot;Hello World&quot;<br>
&quot;two\nlines&quot;<br>
&quot;&quot;This is in quotes&quot;&quot;</p>
<p>字符串常量和字符常量都可以包含任何Unicode字符。例如：</p>
<p>char a = '\u0001';<br>
String a = &quot;\u0001&quot;;</p>
<p>Java语言支持一些特殊的转义字符序列。</p>
<ul>
<li>符号	字符含义</li>
<li>\n	换行 (0x0a)</li>
<li>\r	回车 (0x0d)</li>
<li>\f	换页符(0x0c)</li>
<li>\b	退格 (0x08)</li>
<li>\0	空字符 (0x0)</li>
<li>\s	空格 (0x20)</li>
<li>\t	制表符</li>
<li>&quot;	双引号</li>
<li>'	单引号</li>
<li>\	反斜杠</li>
<li>\ddd	八进制字符 (ddd)</li>
<li>\uxxxx	16进制Unicode字符 (xxxx)</li>
</ul>
<h1 id="自动类型转换">自动类型转换</h1>
<p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</p>
<p>转换从低级到高级。</p>
<p>低  ------------------------------------&gt;  高</p>
<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double<br>
数据类型转换必须满足如下规则：</p>
<ol>
<li>
<p>不能对boolean类型进行类型转换。</p>
</li>
<li>
<p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li>
<p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
<li>
<p>转换过程中可能导致溢出或损失精度，例如：</p>
</li>
</ol>
<p>int i =128;<br>
byte b = (byte)i;<br>
因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<ol start="5">
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li>
</ol>
<p>(int)23.7 == 23;<br>
(int)-45.89f == -45</p>
<h2 id="自动类型转换-2">自动类型转换</h2>
<p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<h2 id="实例-3">实例</h2>
<pre><code class="language-java">public class ZiDongLeiZhuan{
        public static void main(String[] args){
            char c1='a';//定义一个char类型
            int i1 = c1;//char自动类型转换为int
            System.out.println(&quot;char自动类型转换为int后的值等于&quot;+i1);
            char c2 = 'A';//定义一个char类型
            int i2 = c2+1;//char 类型和 int 类型计算
            System.out.println(&quot;char类型和int计算后的值等于&quot;+i2);
        }
}
</code></pre>
<p>运行结果为:</p>
<p>char自动类型转换为int后的值等于97<br>
char类型和int计算后的值等于66<br>
解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。</p>
<h2 id="强制类型转换">强制类型转换</h2>
<ol>
<li>
<p>条件是转换的数据类型必须是兼容的。</p>
</li>
<li>
<p>格式：(type)value type是要强制类型转换后的数据类型 实例：</p>
</li>
</ol>
<p>实例</p>
<pre><code class="language-java">public class QiangZhiZhuanHuan{
    public static void main(String[] args){
        int i1 = 123;
        byte b = (byte)i1;//强制类型转换为byte
        System.out.println(&quot;int强制类型转换为byte后的值等于&quot;+b);
    }
}
</code></pre>
<p>运行结果：</p>
<p>int强制类型转换为byte后的值等于123</p>
<h2 id="隐含强制类型转换">隐含强制类型转换</h2>
<p>1、 整数的默认类型是 int。</p>
<ol start="2">
<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>
</ol>
<p>如果整数的值超出了byte所能表示的范围，结果将对byte类型的范围取余数。例如a=256超出了byte的[-128,127]的范围，所以将257除以byte的范围（256）取余数得到b=1；需要注意的是，当a=200时，此时除了256取余数应该为-56，而不是200。</p>
<p>将浮点类型赋给整数类型的时候，会发生截尾（truncation）。也就是把小数的部分去掉，只留下整数部分。此时如果整数超出目标类型范围，一样将对目标类型的范围取余数。</p>
<p>7种基本类型转换总结如下图：<br>
<img src="https://www.cmsj.in/post-images/1631024373762.png" alt="" loading="lazy"></p>
<h2 id="赋值及表达式中的类型转换">赋值及表达式中的类型转换</h2>
<h2 id="字面值赋值">字面值赋值</h2>
<p>在使用字面值对整数赋值的过程中，可以将int literal赋值给byte short char int，只要不超出范围。这个过程中的类型转换时自动完成的，但是如果你试图将long literal赋给byte，即使没有超出范围，也必须进行强制类型转换。例如 byte b = 10L；是错的，要进行强制转换。</p>
<h2 id="表达式中的自动类型提升">表达式中的自动类型提升</h2>
<p>除了赋值以外，表达式计算过程中也可能发生一些类型转换。在表达式中，类型提升规则如下：</p>
<p>· 所有byte/short/char都被提升为int。</p>
<p>· 如果有一个操作数为long，整个表达式提升为long。float和double情况也一样。</p>
<h1 id="易错点">易错点：</h1>
<p>1.Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析：</p>
<p>long g = (long)9223372036854775807;<br>
long h = (long)-9223372036854775808;</p>
<p>或者<br>
long g = 9223372036854775807;<br>
long h = -9223372036854775808;</p>
<p>会出现以下报错信息：</p>
<p>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problems:<br>
The literal 9223372036854775807 of type int is out of range<br>
The literal 9223372036854775808 of type int is out of range</p>
<p>溢出了~</p>
<p>解决方法在数值后面加上 L：</p>
<p>long value = 9223372036854775807L;</p>
<p>2.引用类型是一个对象类型，它的值是指向内存空间的引用，就是地址，所指向的内存中保存着变量所表示的一个值或一组值。</p>
<p>int a;<br>
a = 250; // 声明变量a的同时，系统给a分配了空间。</p>
<p>引用类型就不是了，只给变量分配了引用空间，数据空间没有分配，因为不知道数据是什么。</p>
<p>错误的例子：</p>
<p>MyDate today;<br>
today.day = 4; // 发生错误，因为today对象的数据空间未分配。</p>
<p>引用类型变量在声明后必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问。</p>
<p>MyDate today;          //将变量分配一个保存引用的空间<br>
today = new MyDate();     // 这句话是2步，首先执行new MyDate（），给today变量开辟数据空间，然后再执行赋值操作</p>
<p>引用变量赋值：</p>
<p>MyDate a，b;       // 在内存开辟两个引用空间<br>
a = new MyDate();       // 开辟MyDate对象的数据空间，并把该空间的首地址赋给a<br>
b = a;                   // 将a存储空间中的地址写到b的存储空间中</p>
<p>3.那么 a+b 是什么类型？</p>
<p>答：在java的世界里，如果比int类型小的类型做运算，java在编译的时候就会将它们统一强转成int类型。当是比int类型大的类型做运算，就会自动转换成它们中最大类型那个。</p>
<p>4.char a = 'S'; char 后面赋值要用单引号，因为是字符型数据类型</p>
<p>String a = &quot;I AM FINE&quot;; String 后面赋值要用双引号，因为是字符串数据类型</p>
<p>5.Java中没有“无符号数”<br>
可以使用long来处理无符号整数(uint)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java程序设计：一些相续正整数的立方和正好等于另一个整数的立方]]></title>
        <id>https://www.cmsj.in/post/java-cheng-xu-she-ji-yi-xie-xiang-xu-zheng-zheng-shu-de-li-fang-he-zheng-hao-deng-yu-ling-yi-ge-zheng-shu-de-li-fang/</id>
        <link href="https://www.cmsj.in/post/java-cheng-xu-she-ji-yi-xie-xiang-xu-zheng-zheng-shu-de-li-fang-he-zheng-hao-deng-yu-ling-yi-ge-zheng-shu-de-li-fang/">
        </link>
        <updated>2020-08-06T17:21:52.000Z</updated>
        <summary type="html"><![CDATA[<p>编写一个应用程序，找到一些相续正整数的立方和正好等于另一个整数的立方。如下图所示：<br>
<img src="https://cms88168.github.io/post-images/1630948999715.png" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>编写一个应用程序，找到一些相续正整数的立方和正好等于另一个整数的立方。如下图所示：<br>
<img src="https://www.cmsj.in/post-images/1630948999715.png" alt="" loading="lazy"></p>
<!-- more -->
<p>相关的程序实现如下：</p>
<pre><code class="language-java">package com.company;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Main {

    static String s = &quot;&quot;;
    static int high = 0;

    public static void main(String[] args) {
        System.out.println(&quot;请输入最大值：&quot;);
        io();
        long sum = 0;
        //sumSaver数组存放从1到数组下标的立方和
        long[] sumSaver = new long[high];
        //i3Saver数组存放数组下表的立方值
        long[] i3Saver = new long[high];
        for (long i = 1; i &lt;= high; i++) {
            i3Saver[(int) i - 1] = i * i * i;
            sum = sum + i3Saver[(int) i - 1];
            sumSaver[(int) i - 1] = sum;

        }
        //要求的最大项数组下标
        for (int i = 3; i &lt;= high; i++) {
            //左边从开始到第j项的和
            for (int j = 1; j &lt; i; j++) {
                //再减去左边第k项的和
                for (int k = 1; k &lt; j; k++) {
                    long temp = sumSaver[j - 1] - sumSaver[k - 1];
                    if (i3Saver[i - 1] == temp) {
                        System.out.printf(&quot;%d³=%d³+...+%d³\n&quot;, i, k + 1, j);
                        break;
                    }
                    if (i3Saver[i - 1] &gt; temp) {
                        break;
                    }
                }
            }
        }
    }

    static void io() {
        try {
            BufferedReader io = new BufferedReader(new InputStreamReader(System.in));
            s = io.readLine();
            try {
                high = Integer.parseInt(s);
            } catch (NumberFormatException e) {
                System.out.println(&quot;请输入数字！&quot;);
                Main.io();
            }
        } catch (IOException e) {
            e.printStackTrace();
            Main.io();
        }
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在NameSilo.com购买域名 文中附送namesilo优惠码 namesilo优惠券]]></title>
        <id>https://www.cmsj.in/post/zai-namesilocom-gou-mai-yu-ming-wen-zhong-fu-song-namesilo-you-hui-ma-namesilo-you-hui-quan/</id>
        <link href="https://www.cmsj.in/post/zai-namesilocom-gou-mai-yu-ming-wen-zhong-fu-song-namesilo-you-hui-ma-namesilo-you-hui-quan/">
        </link>
        <updated>2020-05-02T02:11:13.000Z</updated>
        <summary type="html"><![CDATA[<p>namesilo也算是比较老牌的域名注册商了，我的这个域名就是在这里注册的。而且价格并非namesilo唯一优势，高可用性、高安全性、免费域名隐私保护都是namesilo相对于其他家拥有的优势。而且支持支付宝，可以说是非常方便了。</p>
<p>这里先送上1美元的优惠券 <font color=red><strong>1usdollar</strong></font></p>
]]></summary>
        <content type="html"><![CDATA[<p>namesilo也算是比较老牌的域名注册商了，我的这个域名就是在这里注册的。而且价格并非namesilo唯一优势，高可用性、高安全性、免费域名隐私保护都是namesilo相对于其他家拥有的优势。而且支持支付宝，可以说是非常方便了。</p>
<p>这里先送上1美元的优惠券 <font color=red><strong>1usdollar</strong></font></p>
<!-- more -->
<h2 id="namesilo优势">Namesilo优势</h2>
<p>低价格：com域名为例，新注册域名为8.99美元，续费价格不变，仍为8.99美元。虽说godaddy有Domain Discount Club的8.49美元每年的续费价格（需交58美元一年获取此价格），但即使是达到182个以上域名，godaddy价格低于namesilo的续费价格时候，namesilo仍有一项巨大的优势，就是永久免费的域名隐私，而同样服务在godaddy每年的价格为9.99美金。</p>
<p>高可用性：godaddy树大招风，name server 经常在国内被照顾造成域名解析不正常，其网站本身也有这样的困扰。每次找优惠码尝试的时候，都要挂代理，否则打开一个页面都要好几分钟。而namesilo就好的多，访问页面非常顺畅，而目前为止也没有任何name server被关照的先例。</p>
<p>高安全性：namesilo本身就有类似qq密码保护的安全问题等加强型安全措施，相对于godaddy等单一密码凭证要强上许多，最近又加上了google的TSV（Two Step Verification，两部验证），更是让namesilo的安全系数达到消费级域名服务提供商的顶级水准。当然，还有免费的域名隐私保护更是锦上添花。</p>
<p>免费域名隐私：域名隐私保护不仅可以让域名注册者的信息免于泄露，更是无形当中提高了域名安全性，同时也解决了垃圾邮件的困扰。</p>
<p>支持支付宝：除了paypal和信用卡，支付宝直接支付对于大陆用户来说要方便得多。</p>
<h2 id="1访问网站并注册用户账号">1.访问网站并注册用户账号</h2>
<p>直接去官网：www.namesilo.com<br>
<img src="https://www.cmsj.in/post-images/1630948452805.png" alt="" loading="lazy"></p>
<p>邮箱可以填 QQ邮箱，国家选择 China，注册信息尽量真实。没有必要担心你的真实信息被暴露，Namesilo 会提供免费的 Domain Privacy Protection 服务。</p>
<p>注册完之后，记得去邮箱激活验证邮件。如果没有收到 validation email，可以在用户平台 account 里面 resend validation email.</p>
<h2 id="2选择域名准备注册">2.选择域名准备注册</h2>
<p>在register页面，输入自己想要的域名，点击SEARCH：<br>
<img src="https://www.cmsj.in/post-images/1630948468952.png" alt="" loading="lazy"></p>
<h2 id="3选择域名后缀">3.选择域名后缀</h2>
<p>在你想要注册的后缀前面打√，推荐com，之后点击REGISTER CHECKED DOMAINS：<br>
<img src="https://www.cmsj.in/post-images/1630948481952.png" alt="" loading="lazy"></p>
<h2 id="4选择域名参数并使用优惠码">4.选择域名参数并使用优惠码</h2>
<p><img src="https://www.cmsj.in/post-images/1630948496575.png" alt="" loading="lazy"><br>
如上图所示，可以设置域名的参数。在下方优惠码提交栏可以输入优惠码，之后点击Submit，可以减1刀。再次送上1美元的优惠券 <font color=red><strong>1usdollar</strong></font></p>
<h2 id="5选择支付方式">5.选择支付方式</h2>
<p>目前NameSilo支持支付宝、信用卡、PayPal等多种支付方式，选择一个自己喜欢的支付方式即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Domcomp 在线域名比价大全]]></title>
        <id>https://www.cmsj.in/post/domcomp-zai-xian-yu-ming-bi-jie-da-quan/</id>
        <link href="https://www.cmsj.in/post/domcomp-zai-xian-yu-ming-bi-jie-da-quan/">
        </link>
        <updated>2020-01-31T16:46:17.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.domcomp.com/">Domcomp</a>  网站是一个集合了1800种不同的域名后缀注册价格，让域名收集用户轻松找出最便宜，最优惠的域名注册商，世界各国的域名商会不定期的发布促销或特价活动，该网站可以让你一站式查找最优惠价格的信息。</p>
<p>这个站是真的强 一方面可以查寻域名注册情况 同时还可以比较多个域名注册商价格 我的域名就是在里面找的：）</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.domcomp.com/">Domcomp</a>  网站是一个集合了1800种不同的域名后缀注册价格，让域名收集用户轻松找出最便宜，最优惠的域名注册商，世界各国的域名商会不定期的发布促销或特价活动，该网站可以让你一站式查找最优惠价格的信息。</p>
<p>这个站是真的强 一方面可以查寻域名注册情况 同时还可以比较多个域名注册商价格 我的域名就是在里面找的：）</p>
<!-- more -->
]]></content>
    </entry>
</feed>